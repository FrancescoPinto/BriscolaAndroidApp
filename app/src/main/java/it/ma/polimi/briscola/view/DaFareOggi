1) sistemare la documentazione SOLO DI: Briscola2PMatch, Briscola2PMatchConfig, delle AIPlayer e dei deck
2) generare i javadoc e metterli da qualche parte
FARE TANTI TEST PIU' APPROFONDITI SU TUTTO (riprendi da deck, hai già testato esaustivamente CardNumbers/Suit e Card, ti mancano NeapolitanDeck (lo shuffler non puoi testarlo perché è casuale, lo "testi" nel deck
e poi ti mancano test più approfonditi per tutta la parte di sopra

3) fare esperimento sull'animazione di flip di una carta/moneta (il perché è al punto 8)
4) sviluppare l'activity + fragment delle classifiche/record vecchi dati con un master+details (lascia perdere l'estetica per ora)
5) sviluppare l'activity + fragment per il login + il controller che si occupa di garantire l'autorizzazione a recuperare dati/l'identità
6) sviluppare l'activity + fragment della schermata iniziale (tra le opzioni metti solo FUNZIONALITA' DI GIOCO O DI DATI VECCHI) + un drawer a sinistra per le impostazioni dell'app e i dati profilo + pulsante logout
7) introdurre musica nel menù iniziale e alla pressione dei tasti del menù ecc.
7) sviluppare l'activity + fragment della partita di carte
8) perfezionare la grafica con animazioni carine (PER SEMPLICITA' TU IMPLEMENTA IL GIOCO IN MODO BRUTTO: le carte le fai con delle pseudo immagini che hanno sopra una textview
le carte compaiono e scompaiono nel nulla (non animarle bene, non serve per ora, poi le animazioni le curi dopo ... SOLO una cosa, fa un esperimento con una flip di una imageView
per assicurarti che la tua scelta di non usare surfaceView o OpenGL vada bene


List<CARD> cardList = new ArrayList<>();

    public AbstractCardListWrapper(){}

    public AbstractCardListWrapper(String list){
        if(getMaxNumCardsAllowedInList() != null && list.length() > getMaxNumCardsAllowedInList()*2)
            throw new IllegalArgumentException(getErrorMessage(illegalConstructorArgumentErrorMessage_TOO_LONG));
        List<CARD> temp = new ArrayList<>();

        for(int i = 0; i <= list.length()-1; i = i+2){
            String num = ""+list.charAt(i);
            String suit = ""+list.charAt(i+1);
            temp.add(this.buildCardInstance(num,suit));

        }
        //@TODO q>irrobustire controllando che la stringa sia valida, ovvero: è pari e ogni coppia è una carta (questo già lo controlli), le carte sono tutte diverse (NON puoi forzare che ci siano tutte le carte perché la configurazione da cui ricostruisci potrebbe non essere con deck pieno, PERO' SE SONO 40 CARTE ALLORA DEVONOE ESSERE TUTTE)

        this.cardList = temp;
    }

    public AbstractCardListWrapper(List<CARD> cards){

        if(getMaxNumCardsAllowedInList() != null &&  cards.size() > getMaxNumCardsAllowedInList())
            throw new IllegalArgumentException(getErrorMessage(illegalConstructorArgumentErrorMessage_TOO_LONG));
        cardList = new ArrayList<>(cards);
    }

    @Override
    public boolean equalTo(AbstractCardListWrapper clw){
        if(this.isEmpty() && clw.size() == 0)
            return true;
        else if(this.isEmpty() && !(clw.size() == 0))
            return false;
        else if(!this.isEmpty() && (clw.getCardList().size() == 0))
            return false;
        else {
            for (int i = 0; i < this.size() && i < clw.getCardList().size(); i++) {
                CARD c1 = cardList.get(i);
                CARD c2 = (CARD) clw.getCardList().get(i);
                if (!c1.equalTo(c2))
                    return false;
            }
            return true;

        }
    }


    @Override
    public String toString(){
        String temp = "";
        if(isEmpty())
            return temp;

        for(CARD c: cardList){

            temp += c;
        }
        return temp;
    }

    @Override
    public int size(){
        return cardList.size();
    }


    @Override
    public boolean isEmpty(){
        return cardList.isEmpty();
    }


    @Override
    public boolean containsCard(Card card){
        for(CARD c : cardList)
            if(c.equalTo(card))
                return true;

        return false;
    }

    @Override
    public CARD getCard(int i){
        return cardList.get(i);
    } //todo check dei boundaries

    @Override
    public void appendCard(CARD card){
        if(getMaxNumCardsAllowedInList() != null && this.size() >= getMaxNumCardsAllowedInList())
            throw new IllegalStateException(getErrorMessage(noMoreCardsCanBeAddedErrorMessage));
        cardList.add(card);
    }

    @Override
    public CARD removeCard(int i){
        if(isEmpty())
            throw new IllegalArgumentException(getErrorMessage(operationNotPermittedErrorMessage_EMPTY_LIST));

        if(getMaxNumCardsAllowedInList() != null && i > getMaxNumCardsAllowedInList()-1)
            throw new IndexOutOfBoundsException(getErrorMessage(indexListMaximumExceededErrorMessage));

        if(i >= size() || i < 0 )
            throw new IndexOutOfBoundsException(getErrorMessage(indexListSizeExceededErrorMessage));


        CARD temp = cardList.get(i);
        cardList.remove(i);
        return temp;
    }

    @Override
    public void appendAll(List<CARD> cards){ cardList.addAll(cards);}

    public Integer getMaxNumCardsAllowedInList() {
        return null;
    }

    public abstract CARD buildCardInstance(String num, String suit);

    private String getErrorMessage(String errorName){
        switch(errorName){
            case "illegalConstructorArgumentErrorMessage_TOO_LONG": return this.getClass().getSimpleName() + ": the number of cards in the argument of the constructor should be between 0 and "+getMaxNumCardsAllowedInList();
            case "noMoreCardsCanBeAddedErrorMessage" : return this.getClass().getSimpleName() + " already contains "+getMaxNumCardsAllowedInList()+"cards. No other cards can be added";
            case "operationNotPermittedErrorMessage_EMPTY_LIST" : return this.getClass().getSimpleName() + " is empty, operation not permitted";
            case "indexListSizeExceededErrorMessage" : return this.getClass().getSimpleName() + ": index can not exceed the size ("+size()+"-1) of the list";
            case "indexListMaximumExceededErrorMessage" : return this.getClass().getSimpleName() +": index can not exceed the maximum of "+ (getMaxNumCardsAllowedInList() - 1);
            default: return null;
        }

    }

    @Override
    public List<CARD> getCardList(){
        return cardList;
     }
    @Override
    public void setCardList(List<CARD> cards){
        this.cardList = new ArrayList<>(cards);
    }
}
